package schema

import (
	"gopkg.in/mgo.v2/bson"

	"themis/models"
	"themis/database"
)

// This creates a default schema for the given spaceID and stores it in the storage backends.
// It creates the template using code. We might want to load it from JSON or some other 
// static source at some point. For now, the default schema is hardcoded.
// To support different schemas, this has to pe parameterized. This is easy, but when we want to do this,
// the schema should definitely be loaded from a JSON static source file (or copied from a schema db setup).
func createSchemaForSpaceInStorage(spaceID bson.ObjectId, storageBackends database.StorageBackends) ([]bson.ObjectId, *bson.ObjectId, *bson.ObjectId, error) {
	var err error
	var workItemTypeIDs []bson.ObjectId

	// create and store WorkItemTypes
	workItemTypes := CreateWorkItemTypes()
	for i := range workItemTypes {
		workItemTypes[i].SpaceID = spaceID
		workItemTypes[i].ID, err = storageBackends.WorkItemType.Insert(workItemTypes[i])
		workItemTypeIDs = append(workItemTypeIDs, workItemTypes[i].ID)
		if err != nil {
			return nil, nil, nil, err
		}
	}

	// create and store LinkCategories
	linkCategories := CreateLinkCategories()
	for i := range linkCategories {
		linkCategories[i].SpaceID = spaceID
		linkCategories[i].ID, err = storageBackends.LinkCategory.Insert(linkCategories[i])
		if err != nil {
			return nil, nil, nil, err
		}
	}

	// create and store LinkTypes
	linkTypes := CreateLinkTypes()
	for i := range linkTypes {
		linkTypes[i].SpaceID = spaceID
		// link LinkCategory by looking at the (temporary) ref 
		// attribute generated by the boostrapping
		for j := range linkCategories {
			if linkCategories[j].RefID == linkTypes[i].CategoryRef {
				linkTypes[i].LinkCategoryID = linkCategories[j].ID
			}
		}
		// same for the ref to the source WorkItemType
		for j := range workItemTypes {
			if workItemTypes[j].RefID == linkTypes[i].SourceWorkItemTypeRef {
				linkTypes[i].SourceWorkItemTypeID = workItemTypes[j].ID
			}
		}
		// same for the ref to the target WorkItemType
		for j := range workItemTypes {
			if workItemTypes[j].RefID == linkTypes[i].TargetWorkItemTypeRef {
				linkTypes[i].TargetWorkItemTypeID = workItemTypes[j].ID
			}
		}
		linkTypes[i].ID, err = storageBackends.LinkType.Insert(linkTypes[i])
		if err != nil {
			return nil, nil, nil, err
		}
	}

	// create root area
	rootArea := models.NewArea()
	rootArea.Name = "Root Area"
	rootArea.Description = "Root Area"
	rootArea.SpaceID = spaceID
	rootArea.ID, err = storageBackends.Area.Insert(*rootArea)
	if err != nil {
		return nil, nil, nil, err
	}

	// create root iteration
	rootIteration := models.NewIteration()
	rootIteration.Name = "Root Iteration Name"
	rootIteration.Description = "Root Iteration Description"
	rootIteration.SpaceID = spaceID
	rootIteration.ID, err = storageBackends.Iteration.Insert(*rootIteration)
	if err != nil {
		return nil, nil, nil, err
	}

	return workItemTypeIDs, &rootArea.ID, &rootIteration.ID, nil
}

// CreateWorkItemTypes creates the default work item types.
func CreateWorkItemTypes() []models.WorkItemType {
	workItemTypes := []models.WorkItemType {
		createWorkItemTypeStory(),
		createWorkItemTypeTask(),
		createWorkItemTypeBug(),
	}
	return workItemTypes
}

// CreateLinkCategories creates the default link categories
func CreateLinkCategories() []models.LinkCategory {
	linkCategories := []models.LinkCategory {
		createLinkCategoryDefault(),
	}
	return linkCategories
}

// CreateLinkTypes creates the default link types
func CreateLinkTypes() []models.LinkType {
	linktypes := createLinkTypeChild()
	linktypes = append(linktypes, createLinkTypeBlocks()...)
	linktypes = append(linktypes, createLinkTypeRelated()...)
	return linktypes
}
